
19：20 要自己看的标准包：
strconv包
strings包
sort包
io包
encoding包
database包
crypto包
context包
container包
bufio包
fmt包
errors包


19：21 goroutine实例
19：32 锁的注意事项
	1. 保证Lock和Unlock一定被调用
	2. 被Lock的内容的访问一定要经过锁的过程进行访问
	3. 当没有拿到锁时，拿锁的过程会等待。
	4. 锁有种类之分
19：33先看锁是否还锁着，然后再动数据。
19：33 锁的种类
	1.同步锁 sync.Mutex{}
	 	1.1锁只能被一个goroutine拿到
		1.2 所有其他goroutine必须等待锁释放后才可以争抢
	2. 读写锁 sync.RWMutex{}
		2.1 写锁只能一个goroutine拿到
		2.2 其他要拿锁的必须等待写锁释放后才可以取争抢
		2.3 读锁可以同时被多个goroutine拿到
		2.4 读锁不阻止其他goroutine去拿（读）锁
		2.5 读锁在释放前，拿写锁的goroutine等待，直到所有锁释放后才可以拿到写锁。


19：42 读写锁案例

20：06 生产者、消费者模型

20：28 golang 的 sync（think）包
sync.WaitGroup
Add: 添加计数器计数
Done：减少计数器计数
Wait：等待计数器数字归零
经典案例：
下课铃：所有任务都完成，再进入下一步。
上课铃：所有任务一起开始。

20:48 sync.Once
不管怎样只做一次。
一般是用作准备条件的
Do：想要只执行一次的内容
经典案例： 
多线程中共享内容的初始化，且只初始化一次。



20：59 sync.Cond （Condition）重量级的东西
Wait: 等待某个条件
Broadcast：广播给所有在这个cond Wait的routine
Signal： 只发送一条消息，只唤醒一个在这个cond Wait的 routine
经典案例：
共享的线程安全队列
生产者消费者模型


21：13 指针的使用（没懂）

21：17 模拟数据库

21：26 sync.map
这是一个线程安全的map。 
可以容纳任何类型的数据。


21：37 无锁编程
锁带来安全的同时，带来了性能的降低。
无锁编程是指：在特定场景，不使用锁同时又做到线程安全，可以大大提高系统的性能。
能不用锁的时候，不用锁。
不使用锁的同时有做到线程安全，可以大大提高性能。

经典案例：
网络服务器运行时，会读取一个内存中的对象，以确定当前的配置是什么，如何给客户端返回数据。

网络服务器周期性地从一个文件加载配置到内存中的对象，以确保内存中对象在一定时间后生效。

网络服务器的访问量非常大。
22：03 goroutine大坑
传入参数



